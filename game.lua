-- Queuing music to queueable source copied from love2d.org/wiki/Decoder and edited to purpose

_G.enemy = require("enemy")


function ReturnGame(song)
    local game = {}
    print("making game")


    game.Init = function ()
        if song == nil then
            game.song = {}
            game.song.decoder = love.sound.newDecoder("assets/songs/Alright/song.wav")
            game.song.queueableSource = love.audio.newQueueableSource(game.song.decoder:getSampleRate(), game.song.decoder:getBitDepth(), game.song.decoder:getChannelCount())
        else
            game.song = {}
            game.song.decoder = love.sound.newDecoder((song_list[menu.selected_song].folder_path)..menu.song.file_extension)
            game.song.queueableSource = love.audio.newQueueableSource(game.song.decoder:getSampleRate(), game.song.decoder:getBitDepth(), game.song.decoder:getChannelCount())
            
            love.graphics.setColor(song.average_colour:unpack())
        end
        game.StartSong()
        game.enemy_storage = {}
    end


    game.BufferSong = function ()
        local freeBufferCount = game.song.queueableSource:getFreeBufferCount()
        for i = 1, freeBufferCount do
            local soundData = game.song.decoder:decode()
            game.song.queueableSource:queue(soundData)
        end
    end

    game.StartSong = function ()
        game.BufferSong()
        game.song.queueableSource:play()
    end

    game.Update = function (dt)
        game.BufferSong()
        game.ProgressEnemies(dt)
        game.GetEnemiesDueSpawning()
        --game.PlayerKillEnemies()
        --game.EnemiesDamagePlayer()
        --game.LaserDamagePlayer()
    end

    game.Render = function ()
        local up, down, left, right = textures.buttons.up, textures.buttons.down, textures.buttons.left, textures.buttons.right
        local up_pos, down_pos, left_pos, right_pos = button_positions.up, button_positions.down, button_positions.left, button_positions.right
        local zoom = 5


        love.graphics.draw(up, up_pos.x, up_pos.y, 0, zoom, zoom, up:getWidth()/2,up:getHeight()/2)
        love.graphics.draw(down, down_pos.x, down_pos.y, 0, zoom, zoom, down:getWidth()/2,down:getHeight()/2)
        love.graphics.draw(left, left_pos.x, left_pos.y, 0, zoom, zoom, left:getWidth()/2,left:getHeight()/2)
        love.graphics.draw(right, right_pos.x, right_pos.y, 0, zoom, zoom, right:getWidth()/2,right:getHeight()/2)

        game.RenderEnemies()
    end

    game.ProgressEnemies = function (dt)
        if #game.enemy_storage > 0 then
            for index,enemy in pairs(game.enemy_storage) do
                --print("updating enemy")
                --enemy.Update(dt)
            end
        end
    end


    game.GetEnemiesDueSpawning = function ()
        if #game.enemy_storage < 1 then
            print("making eneym")
            table.insert(game.enemy_storage, ReturnEnemy("u", 0.1, 3))
            table.insert(game.enemy_storage, ReturnEnemy("d", 0.1, 3))
            table.insert(game.enemy_storage, ReturnEnemy("l", 0.1, 3))
            table.insert(game.enemy_storage, ReturnEnemy("r", 0.1, 3))
            table.insert(game.enemy_storage, ReturnEnemy("u", 0.1, 4))
            table.insert(game.enemy_storage, ReturnEnemy("u", 0.1, 5))
            table.insert(game.enemy_storage, ReturnEnemy("u", 0.1, 6))
        end
    end

    game.RenderEnemies = function ()
        if #game.enemy_storage > 0 then
            for index,enemy in pairs(game.enemy_storage) do
                enemy.Render()
            end
        end 
    end

    -- GENERATED BY GOOGLE GEMINI AI 

    -- This module's functions are intended to be added to the global 'game' table.
    -- It assumes 'game.loadLevelData' already exists.

    --- Loads all enemies from a level file, calculates their
    -- absolute spawn time, and stores them in the global 'game.enemy_storage' list.
    -- This is an "unsafe" version that assumes all data in the
    -- JSON file is 100% valid and will crash if it is not.
    -- It assumes 'game.enemy_storage' and 'ReturnEnemy' exist in the global scope.
    -- @param levelFilename (string) The path to the level.json file.
    function game.loadEnemiesFromLevel(levelFilename)
        
        -- 1. Load the level data (assumes game.loadLevelData exists)
        local levelData = loadJSONData(levelFilename)

        -- Add a minimal guard clause to stop execution if loading failed.
        -- This satisfies type-checkers without full error handling.
        if not levelData then
            return
        end


        -- 2. Iterate over all top-level keys (the timestamps)
        for timestampKey, timestampData in pairs(levelData) do
            
            -- 3. Convert timestamp key to a number
            local timestampValue = tonumber(timestampKey)
            
            -- 4. Check if it's a valid non-negative timestamp (>= 0)
            --    and if it has an 'enm' table to process.
            if timestampValue and timestampValue >= 0 and timestampData.enm then
                
                -- 5. Iterate over all enemies for this timestamp (assumes 'enm' exists)
                for id, enemy in pairs(timestampData.enm) do
                    
                    -- 6. Calculate the total spawn time (assumes 'time' exists and is a number)
                    local enemyTime = tonumber(enemy.time)
                    local totalSpawnTime = timestampValue + enemyTime
                    
                    -- 7. Call the global function (assumes 'dir' and 'dmg' exist)
                    local newEnemyObject = ReturnEnemy(enemy.dir, enemy.dmg, totalSpawnTime)
                    
                    -- 8. Insert the new enemy into the global storage list
                    table.insert(game.enemy_storage, newEnemyObject)
                end
            end
        end
    end

    -- --- Example Usage ---
    -- (This version is faster but will error on bad data)
    --
    -- -- In your main.lua file:
    --
    -- -- 1. Your game table and ReturnEnemy function MUST be global
    -- game = {
    --     enemy_storage = {} -- This is the table we will populate
    -- }
    --
    -- -- 1b. Load and assign the level loader
    -- game.loadLevelData = require("level_loader")
    --
    -- -- 1c. Load this script (e.g., using dofile() or require())
    -- -- require("enemy_spawner_unsafe") -- This will add the function to 'game'
    --
    -- function ReturnEnemy(direction, damage, totalSpawnTime)
    --     -- It returns a table (or "object")
    --     return {
    --         dir = direction,
    --         dmg = tonumber(damage),
    --         spawn_time = totalSpawnTime, -- Store the new calculated time
    --         is_active = false
    --     }
    -- end
    --
    -- -- 3. (This step is now done by loading the file)
    --
    -- -- 4. Call the function once at the start of your game
    -- game.loadEnemiesFromLevel_unsafe("level.json")
    --
    -- -- 5. Now, game.enemy_storage is populated!
    -- -- print("Total enemies loaded: " .. #game.enemy_storage)
    -- -- for i, enemy in ipairs(game.enemy_storage) do
    -- --     print("  Enemy " .. i .. " spawns at: " .. enemy.spawn_time)
    -- -- end


    -- No return statement; the function is attached to the 'game' table directly.




    -- END OF AI GENERATION

    return game
end
